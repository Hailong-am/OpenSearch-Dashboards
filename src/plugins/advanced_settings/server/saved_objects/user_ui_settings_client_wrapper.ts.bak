/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  SavedObject,
  SavedObjectsBaseOptions,
  SavedObjectsClientWrapperFactory,
  SavedObjectsUpdateOptions,
  SavedObjectsUpdateResponse,
  CoreStart,
  AuthStatus,
  SavedObjectsErrorHelpers,
  OpenSearchDashboardsRequest,
  ACL,
  SavedObjectsCreateOptions,
} from '../../../../core/server';
import { Logger } from '../../../../core/server';

export interface AuthInfo {
  backend_roles?: string[];
  user_name?: string;
}

export const hashUserName = (username: string) => {
  return username;
};

/**
 * This saved object client wrapper offers methods to get and update UI settings considering
 * the context of the current user
 */
export class UserUISettingsClientWrapper {
  constructor(
    private readonly logger: Logger,
    private readonly savedObjectsPermissionEnabled: boolean
  ) {}
  private core: CoreStart | undefined;

  public setCore(core: CoreStart) {
    this.core = core;
  }

  private extractUserName(request: OpenSearchDashboardsRequest) {
    const authInfoResp = this.core?.http.auth.get(request);

    if (authInfoResp?.status === AuthStatus.authenticated) {
      const authInfo = authInfoResp?.state as { authInfo: AuthInfo } | null;
      return authInfo?.authInfo?.user_name;
    }
    return undefined;
  }

  public wrapperFactory: SavedObjectsClientWrapperFactory = (wrapperOptions) => {
    const getUiSettings = async <T = unknown>(
      type: string,
      id: string,
      options: SavedObjectsBaseOptions = {}
    ): Promise<SavedObject<T>> => {
      const userName = this.extractUserName(wrapperOptions.request);

      /**
       * When getting ui settings within a workspace, it will combine the workspace ui settings with
       * the global ui settings and workspace ui settings have higher priority if the same setting
       * was defined in both places
       */
      if (type === 'config' && userName) {
        this.logger.debug(`getting ui settings for ${userName} with id ${id}`);
        // global value
        const configObject = await wrapperOptions.client.get<Record<string, any>>(
          'config',
          id,
          options
        );
        try {
          // user level
          const userConfigObject = await wrapperOptions.client.get<Record<string, any>>(
            'config',
            hashUserName(userName),
            options
          );

          configObject.attributes = {
            ...configObject.attributes,
            ...(userConfigObject ? userConfigObject.attributes : {}),
          };
        } catch (err) {
          // ignore
        }

        return configObject as SavedObject<T>;
      }

      return wrapperOptions.client.get(type, id, options);
    };

    const updateUiSettings = async <T = unknown>(
      type: string,
      id: string,
      attributes: Partial<T>,
      options: SavedObjectsUpdateOptions = {}
    ): Promise<SavedObjectsUpdateResponse<T>> => {
      const userName = this.extractUserName(wrapperOptions.request);

      if (type === 'config' && userName && this.core) {
        const allRegisteredSettings = this.core.uiSettings
          .asScopedToClient(wrapperOptions.client)
          .getRegistered();

        const userLevelKeys = [] as string[];
        Object.keys(allRegisteredSettings).forEach((key) => {
          const setting = allRegisteredSettings[key];
          if (setting.scope === 'user') {
            userLevelKeys.push(key);
          }
        });

        const userLevelSettings = {} as Partial<T>;
        const globalSettings = {} as Partial<T>;

        Object.entries(attributes).forEach(([key, value]) => {
          if (userLevelKeys.includes(key)) {
            Object.assign(userLevelSettings, { [key]: value });
          } else {
            Object.assign(globalSettings, { [key]: value });
          }
        });

        let updateRes: SavedObjectsUpdateResponse<T> = {
          attributes,
          references: undefined,
          id,
          type: 'config',
        };

        const docId = hashUserName(userName);

        // update user level settings
        if (Object.keys(userLevelSettings).length > 0) {
          try {
            await wrapperOptions.client.update(type, docId, userLevelSettings, options);
          } catch (error) {
            if (!SavedObjectsErrorHelpers.isNotFoundError(error)) {
              throw error;
            }

            let createOptions: SavedObjectsCreateOptions = { id: docId };
            if (this.savedObjectsPermissionEnabled) {
              const permissionObject = new ACL()
                .addPermission(['write'], {
                  users: [userName],
                })
                .getPermissions();

              createOptions = { ...options, permissions: permissionObject };
            }

            await wrapperOptions.client.create(type, userLevelSettings, createOptions);
          }
        }

        // update global ui settings
        if (Object.keys(globalSettings).length > 0) {
          updateRes = await wrapperOptions.client.update(type, id, globalSettings, options);
        }
        return updateRes;
      }
      return wrapperOptions.client.update(type, id, attributes, options);
    };

    return {
      ...wrapperOptions.client,
      checkConflicts: wrapperOptions.client.checkConflicts,
      errors: wrapperOptions.client.errors,
      addToNamespaces: wrapperOptions.client.addToNamespaces,
      deleteFromNamespaces: wrapperOptions.client.deleteFromNamespaces,
      find: wrapperOptions.client.find,
      bulkGet: wrapperOptions.client.bulkGet,
      create: wrapperOptions.client.create,
      bulkCreate: wrapperOptions.client.bulkCreate,
      delete: wrapperOptions.client.delete,
      bulkUpdate: wrapperOptions.client.bulkUpdate,
      deleteByWorkspace: wrapperOptions.client.deleteByWorkspace,
      get: getUiSettings,
      update: updateUiSettings,
    };
  };
}
